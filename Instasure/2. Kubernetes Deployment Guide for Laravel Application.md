# Kubernetes Deployment Guide for Laravel Application

## Overview
This guide will help you deploy your Laravel application to Kubernetes using the provided manifests.

## Prerequisites

1. **Kubernetes Cluster**: Ensure you have a running Kubernetes cluster
2. **kubectl**: Install and configure kubectl to communicate with your cluster
3. **Docker Image**: Build and push your Laravel app image to a registry accessible by your cluster

## Building and Pushing Docker Image

```bash
# Build the Docker image
docker build -t your-registry/instasure-dockerized:latest .

# Push to your registry
docker push your-registry/instasure-dockerized:latest
```

**Important**: Update the image name in the deployment:
```yaml
# In laravel-app-deployment, change:
image: instasure-dockerized_app:latest
# To:
image: your-registry/instasure-dockerized:latest
```

## Pre-deployment Setup

### 1. Create Required Directories
On your Kubernetes nodes, create the directories for persistent volumes:

```bash
# On each node where you want to store data
sudo mkdir -p /data/mysql
sudo mkdir -p /data/redis
sudo chmod 755 /data/mysql /data/redis
```

### 2. Update Host Paths
Update the PersistentVolume hostPath in the manifest to match your actual paths:

```yaml
# Update this path to your actual code location
hostPath:
  path: /home/ashraful/gitlab_project/instasure-dockerized
```

## Deployment Steps

### 1. Apply the Kubernetes Manifests

```bash
# Apply all manifests
kubectl apply -f laravel-k8s-manifests.yaml

# Or apply them in order (recommended)
kubectl apply -f laravel-k8s-manifests.yaml
```

### 2. Verify Deployment

```bash
# Check namespace
kubectl get namespaces

# Check all resources in the laravel-app namespace
kubectl get all -n laravel-app

# Check persistent volumes
kubectl get pv

# Check persistent volume claims
kubectl get pvc -n laravel-app

# Check pods status
kubectl get pods -n laravel-app
```

### 3. Wait for Pods to be Ready

```bash
# Watch pods until they're running
kubectl get pods -n laravel-app -w

# Check logs if pods have issues
kubectl logs -n laravel-app <pod-name>
```

## Accessing Your Application

### 1. Web Application (Nginx)
- **URL**: `http://<node-ip>:30080`
- **HTTPS**: `https://<node-ip>:30443`

### 2. PHPMyAdmin
- **URL**: `http://<node-ip>:30081`
- **Username**: `root`
- **Password**: `root_password`

### 3. Database Access (External)
- **Host**: `<node-ip>`
- **Port**: `30307`
- **Username**: `laravel_user`
- **Password**: `laravel_password`
- **Database**: `laravel_db`

### 4. Redis Access (External)
- **Host**: `<node-ip>`
- **Port**: `30380`

## Configuration Updates

### 1. Environment Variables
Update the `laravel-env` ConfigMap to modify Laravel environment variables:

```bash
kubectl edit configmap laravel-env -n laravel-app
```

### 2. Secrets
Update secrets using kubectl:

```bash
# Update MySQL password
kubectl create secret generic mysql-secret \
  --from-literal=mysql-root-password=your-new-password \
  --from-literal=mysql-password=your-laravel-password \
  --dry-run=client -o yaml | kubectl apply -n laravel-app -f -
```

### 3. PHP Configuration
Update PHP settings by editing the ConfigMap:

```bash
kubectl edit configmap php-config -n laravel-app
```

## Scaling

### Scale Deployments
```bash
# Scale Nginx
kubectl scale deployment nginx-deployment --replicas=3 -n laravel-app

# Scale Laravel App
kubectl scale deployment laravel-app-deployment --replicas=2 -n laravel-app
```

## Troubleshooting

### 1. Check Pod Logs
```bash
kubectl logs -n laravel-app deployment/laravel-app-deployment
kubectl logs -n laravel-app deployment/nginx-deployment
kubectl logs -n laravel-app deployment/mysql-deployment
```

### 2. Debug Pod Issues
```bash
# Describe pod for events
kubectl describe pod <pod-name> -n laravel-app

# Get into a running pod
kubectl exec -it <pod-name> -n laravel-app -- /bin/bash
```

### 3. Common Issues

**Issue**: Pods stuck in Pending state
**Solution**: Check if PersistentVolumes are bound:
```bash
kubectl get pv
kubectl get pvc -n laravel-app
```

**Issue**: Database connection failed
**Solution**: Ensure MySQL pod is running and service is accessible:
```bash
kubectl get svc mysql-service -n laravel-app
kubectl exec -it <laravel-pod> -n laravel-app -- ping mysql-service
```

**Issue**: Nginx 502 Bad Gateway
**Solution**: Check if Laravel app service is running:
```bash
kubectl get pods -n laravel-app -l app=laravel-app
kubectl logs -n laravel-app deployment/laravel-app-deployment
```

## Production Considerations

### 1. Resource Limits
The manifests include basic resource requests and limits. Adjust based on your needs:

```yaml
resources:
  requests:
    memory: "512Mi"
    cpu: "250m"
  limits:
    memory: "1Gi"
    cpu: "500m"
```

### 2. Storage
- Consider using dynamic provisioning with cloud storage for production
- Set up proper backup strategies for MySQL data
- Use appropriate StorageClass for your environment

### 3. Security
- Update default passwords in secrets
- Use proper RBAC permissions
- Consider network policies for pod-to-pod communication
- Use TLS certificates for HTTPS

### 4. Monitoring
- Set up proper monitoring and logging
- Use health checks and readiness probes (already included)
- Monitor resource usage and adjust limits accordingly

### 5. High Availability
- Run multiple replicas of stateless services (Nginx, Laravel app)
- Use appropriate anti-affinity rules for pod distribution
- Set up database replication if needed

## Cleanup

To remove the entire application:

```bash
kubectl delete namespace laravel-app
kubectl delete pv mysql-pv redis-pv app-code-pv
kubectl delete storageclass local-storage
```

## Advanced Configuration

### Using Ingress (Recommended for Production)

Create an Ingress resource instead of using NodePort:

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: laravel-ingress
  namespace: laravel-app
spec:
  rules:
  - host: your-domain.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: nginx-service
            port:
              number: 80
```

### Using External Database

If you want to use an external database service, remove the MySQL deployment and update the ConfigMap:

```yaml
data:
  DB_HOST: "your-external-db-host"
  DB_PORT: "3306"
```
